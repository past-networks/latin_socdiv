---
title: "economic_complexity"
author: "Matteo Mazzamurro"
date: "2024-03-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
This R markdown allows to reproduce the preliminary steps to study the economic complexity of the Roman empire.
The input data are the (Latin) inscriptions containing occupational information.
The output are tables of occupation counts per geographic unit, before and after the correction of uncertainty and biases.

# Structure
The document is structured as follows:
* Preliminaries: 
  Loading the necessary packages and data.
* Defining consistent occupational units by standardizing the spelling. 
* Defining different geographical units: modern countries, Roman provinces, cities.
* Create the tables of occupational counts per geographical units.
* Deal with the uncertainty and biases in the datasets.

# Preliminaries
## Packages
The following libraries are required.
```{r List required packages}
required_packages <- c("jsonlite",     # read json files
                       "arrow",        # read parquet files
                       "tidyverse",    # data cleaning and visualisation
                       "stringi",      # handle strings for spelling standardisation
                       "sf",           # load and handle spatial files
                       "raster",       # handle spatial files
                       "units",        # add physical units for geographic comparison
                       "ggspatial",    # additional plot features for spatial data
                       "triangulr")    # triangular distribution 
```

One needs to install them if they have not been installed yet.
```{r Install missing packages}
packages_to_install <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(packages_to_install)) install.packages(packages_to_install)
```

Finally, one needs to load them.
```{r Load required packages}
invisible(lapply(required_packages, library, character.only = TRUE))
```

Note that we use the following versions of the packages:
* jsonlite    : 1.8.7
* arrow       : 15.0.1
* tidyverse   : 2.0.0
* stringi     : 1.7.12
* sf          : 1.0.15
* raster      : 3.6.26
* units       : 0.8.2
* ggspatial   : 1.1.9
* triangulr   : 1.2.1

These were loaded in the R version 4.3.0.

To check your version of an installed package and R, you may use the following commands.
```{r check R and package version}
# R version
R.version

# example package version
packageVersion("tidyverse")
```

If a package has been updated since the release of this code, using the newer version may cause issues.

If the installed version is causing issues, one can try to solve them by installing the specific versions of the packages by uncommenting and running the following code. 
Note, however, that these older versions of the packages may not be available for newer versions of R, in which case it will be necessary to switch to an older version of R to run the code (please refer to the cran.r website on how to do that: https://cran.r-project.org/index.html).

```{r}
# #install devtools if not already installed
# if (!"devtools" %in% installed.packages()[,"Package"]) install.packages("devtools")
# 
# #load devtools
# library(devtools)
# 
# #install specific versions of the packages
# install_version("jsonlite", version = "1.8.7")
# install_version("arrow", version = "15.0.1")
# install_version("tidyverse", version = "2.0.0")
# install_version("stringi", version = "1.7.12")
# install_version("sf", version = "1.0.15")
# install_version("raster", version = "3.6.26")
# install_version("units", version = "0.8.2")
# install_version("ggspatial", version = "1.1.9")
# install_version("triangulr", version = "1.2.1")
# 
# #load packages
# invisible(lapply(required_packages, library, character.only = TRUE))
```

## Data TO MODIFY WITH CORRECT PATHS
CREATE A NEW DIRECTORY
DOWNLOAD FILES IN IT TO DO

Read the data on inscriptions and standardised spelling
```{r read data on inscriptions}
# inscriptions
inscriptions <- read_parquet("../../data/economic_complexity/LIST_occupsorgs_industry_simple_20231206.parquet")

# occupations to merge 
occupations_all <- read_delim("../../data/economic_complexity/occupations.csv", delim=";")
occupations_to_merge <- read_delim("../../data/economic_complexity/occupations_to_merge.csv", delim=";")

# inscriptions containing people
EDH_people <- read_csv("C:/Users/au732923/OneDrive - Aarhus Universitet/Desktop/PSNP/EDH_sna/data/EDH_people_2021.csv")

# epitaphs
epitaphs <- inscriptions[inscriptions$type_of_inscription_auto %in% c("epitaph"),]

# greek inscriptions
greek_inscriptions <- read_parquet("../../data/economic_complexity/GIST_v1-1.parquet")
```

Read the data on geographical units. THESE ARE LOCAL PATHS. NEED INSTRUCTION ON HOW TO DOWNLOAD
```{r geographical data}
# cities based on Hanson's dataset
cities <- st_read("../../data/economic_complexity/roman_cities_pop.geojson")

# Roman provinces (digitised and corrected by Adam PaÅ¾out)
## read the data
provinces <- read_sf("../../data/economic_complexity/roman_provinces_cleaned/roman_provinces_foranalysisdissolved.shp")
## transform it in a relevant coordinate reference system
provinces <- st_transform(provinces, crs=crs("epsg:4326"))
## delete Roma since it lies inside Latium
provinces <- provinces[!provinces$province=="Roma",]
## delete unnecessary columns for our scopes
provinces <- provinces[,c("province","geometry")]

# country borders
## read the data from local path. Need to download from https://public.opendatasoft.com/api/explore/v2.1/catalog/datasets/world-administrative-boundaries/exports/shp 
world_sf <- read_sf('../../data/economic_complexity/world-administrative-boundaries/world-administrative-boundaries.shp') 
## dissolve the administrative boundaries for visualisation purposes
world_no_borders_sf <- st_union(world_sf) 
```

# Occupational units
First, select only the inscriptions containing information on occupations
```{r select inscriptions with occupations}
inscriptions_w_occupations <- inscriptions[inscriptions$occups_N>0,]
```

ATTEMPT: CREATE STANDARD SPELLING DF
```{r TO CHECK}
occupations_to_merge_min <- occupations_to_merge[,c("Main_term","To_be_merged")]

occupations_to_merge_separated <- occupations_to_merge_min %>%
  separate_rows(To_be_merged, sep = ", ") %>%
  mutate(To_be_merged = trimws(To_be_merged)) # Remove leading/trailing spaces if any

# Rename columns if needed
colnames(occupations_to_merge_separated) <- c("standard_spelling", "alternative_spellings")

```


Add a standard spelling column to the occupations.
```{r standardise occupation spelling TO CHECK}
# ensure no unwanted space are there in the terms
occupations_all$Term <- trim(occupations_all$Term)

# find full names of occupations by attaching Term2 if present
occupations_all$Term_full <- ifelse(!is.na(occupations_all$Term2),
                                    paste(occupations_all$Term,occupations_all$Term2),
                                    occupations_all$Term)
                                           
#initialise column of standard spelling 
occupations_all$std_spelling <- NA

for (i in seq(nrow(occupations_all))) {
  occ_term <- occupations_all$Term_full[i]
  # for an occupational term, see if it needs to be merged 
  #occ_word_match <- str_detect(occupations_to_merge$To_be_merged,occ_term)

 # in case it does, merge it, otherwise, the term itself is the standard spelling
  #occupations_all$std_spelling[i] <- ifelse(any(occ_word_match),
  #       occupations_to_merge$Main_term[occ_word_match],
  #       occ_term)
  
  
   # MISTAKE HERE: NEED TO match this
  occupations_all$std_spelling[i] <- ifelse(occ_term %in% occupations_to_merge_separated$alternative_spellings,
                                            occupations_to_merge_separated$standard_spelling[which(occupations_to_merge_separated$alternative_spellings==occ_term)],
                                            occ_term
                                            )
}

# select only necessary columns
occupations_dictionary <- unique(occupations_all[,c("Term_full","std_spelling")]) %>%
  setNames(c("Term","std_spelling"))

# initialise new column of standard spelling for occupations in inscriptions
inscriptions_w_occupations$occups_std <- rep(list(NA),nrow(inscriptions_w_occupations))

for (i in seq(nrow(inscriptions_w_occupations))){
  # extract an inscription
  inscription <- inscriptions_w_occupations[i,]
  # find the occupations in the inscription and associate it with the standard spellings
  inscription_occ <- data.frame(Term=unlist(inscription$occups)) %>%
    left_join(occupations_dictionary,
              by = "Term")
  # save the standard spellings for the occupations in the inscription
  inscriptions_w_occupations$occups_std[[i]] <- inscription_occ$std_spelling
}
```

Extract info on unique occupations in inscriptions to fil the table
```{r unique occupations for online table TO DO}
unique_occupations_in_inscriptions_df <- data.frame(std_spelling = sort(unique(unlist(inscriptions_w_occupations$occups_std)))) %>% 
  left_join(occupations_all,by=join_by(std_spelling),)

#write.csv(unique_occupations_in_inscriptions_df,"../../results/economic_complexity/unique_occupations_in_inscriptions.csv")

```

# Geographical units
## Intro
Note that naive methods (e.g., using a cell raster) do not work, as each geographical unit must have at least one inscription and the data is very sparse.

As a first step, convert the inscriptions into a sf
```{r create sf of inscriptions}
# occupations with inscriptions
inscriptions_w_occupations_sf <- st_as_sf(inscriptions_w_occupations,
                                          coords = c("Longitude","Latitude"),
                                          crs = crs("epsg:4326"))

# epitaphs
epitaphs_sf <- st_as_sf(epitaphs,
                        coords = c("Longitude","Latitude"),
                        crs = crs("epsg:4326"))

# greek inscriptions (See if more columns will be necessary)
greek_inscriptions_sf <- st_as_sf(na.omit(greek_inscriptions[,c("PHI_ID","Longitude","Latitude")]),
                                  coords = c("Longitude","Latitude"),
                                  crs = crs("epsg:4326"))
```

## Modern countries
### Inscriptions with occupations
First associate the inscriptions with occupations to the corresponding (closest) country
```{r inscriptions in countries}
inscriptions_coordinates <- data.frame(st_coordinates(inscriptions_w_occupations_sf)) %>% 
  setNames(c("Longitude","Latitude"))

inscriptions_in_countries <- cbind(inscriptions_w_occupations_sf,
                                   country = world_sf$iso3[st_nearest_feature(inscriptions_w_occupations_sf,world_sf)],
                                   inscriptions_coordinates)
```

Visual check: represent the inscriptions as points on a map and colour them according to the province they are assigned to
```{r visualise distribution of inscriptions by country}
# base map
inscriptions_by_country_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_countries,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_coordinates$Longitude), 
                    max(inscriptions_coordinates$Longitude)), 
           ylim = c(min(inscriptions_coordinates$Latitude), 
                    max(inscriptions_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_country_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_country.pdf", inscriptions_by_country_plot, width = 7, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_country.jpeg", inscriptions_by_country_plot, width = 7, height = 5.5, dpi = 300)
```

One inscription lies in Norway, which is very suspicious. Create another file without it
```{r delete inscription in Norway and plot}
inscriptions_in_countries_no_Norway <- inscriptions_in_countries[!inscriptions_in_countries$country=="NOR",]

# base map
inscriptions_by_country_no_Norway_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_countries_no_Norway,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_in_countries_no_Norway$Longitude), 
                    max(inscriptions_in_countries_no_Norway$Longitude)), 
           ylim = c(min(inscriptions_in_countries_no_Norway$Latitude), 
                    max(inscriptions_in_countries_no_Norway$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_country_no_Norway_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_country_no_Norway.pdf", inscriptions_by_country_no_Norway_plot, width = 10, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_country_no_Norway.jpeg", inscriptions_by_country_no_Norway_plot, width = 10, height = 5.5, dpi = 300)
```

### Epitaphs
We do the same for the epitaphs.
```{r epitaphs in countries}
epitaphs_coordinates <- data.frame(st_coordinates(epitaphs_sf)) %>% 
  setNames(c("Longitude","Latitude"))

epitaphs_in_countries <- cbind(epitaphs_sf,
                                   country = world_sf$iso3[st_nearest_feature(epitaphs_sf,world_sf)],
                                   epitaphs_coordinates)
```
Visual check 
```{r map epitaphs by country}
# base map
epitaphs_by_country_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = epitaphs_in_countries,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(epitaphs_coordinates$Longitude), 
                    max(epitaphs_coordinates$Longitude)), 
           ylim = c(min(epitaphs_coordinates$Latitude), 
                    max(epitaphs_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(epitaphs_by_country_plot)
#ggsave("../../figures/economic_complexity/epitaphs_by_country.pdf", epitaphs_by_country_plot, width = 7, height = 5.5)
#ggsave("../../figures/economic_complexity/epitaphs_by_country.jpeg", epitaphs_by_country_plot, width = 7, height = 5.5, dpi = 300)
```

### Greek inscriptions
Finally do the same with the Greek inscriptions.
Associate Greek inscriptions to the closest country.
```{r epitaphs in countries}
greek_inscriptions_coordinates <- data.frame(st_coordinates(greek_inscriptions_sf)) %>% 
  setNames(c("Longitude","Latitude"))

greek_inscriptions_in_countries <- cbind(greek_inscriptions_sf,
                                   country = world_sf$iso3[st_nearest_feature(greek_inscriptions_sf,world_sf)],
                                   greek_inscriptions_coordinates)
```

Map the Greek inscriptions by country
```{r map epitaphs by country DO NOT RUN NEEDS TO BE MODIFIED}
# base map
greek_inscriptions_by_country_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = greek_inscriptions_in_countries,
             aes(color = country)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(greek_inscriptions_coordinates$Longitude), 
                    max(greek_inscriptions_coordinates$Longitude)), 
           ylim = c(min(greek_inscriptions_coordinates$Latitude), 
                    max(greek_inscriptions_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(greek_inscriptions_by_country_plot)
#ggsave("../../figures/economic_complexity/greek_inscriptions_by_country.pdf", greek_inscriptions_by_country_plot, width = 7, height = 5.5)
#ggsave("../../figures/economic_complexity/greek_inscriptions_by_country.jpeg", greek_inscriptions_by_country_plot, width = 7, height = 5.5, dpi = 300)
```

## Roman provinces
### Inscriptions with occupations
Repeat the same process using as geographical units the Roman provinces at Trajan's time.
Note that province borders were constantly shifting, so this choice is in principle not more meaningful than using modern country borders.

Associate each inscription to the province in which it falls
```{r inscriptions in provinces}
inscriptions_in_provinces <- st_join(inscriptions_w_occupations_sf, provinces)
inscriptions_in_provinces$Latitude <- inscriptions_w_occupations$Latitude
inscriptions_in_provinces$Longitude <- inscriptions_w_occupations$Longitude
```

Notice that 72 inscriptions lie outside of the borders of the provinces.
```{r inscriptions without a province}
unassigned_inscriptions_index <- which(is.na(inscriptions_in_provinces$province))
unassigned_inscriptions <- inscriptions_w_occupations[unassigned_inscriptions_index,]
unassigned_inscriptions_sf <- st_as_sf(unassigned_inscriptions,
                                       coords = c("Longitude","Latitude"),
                                       crs = crs("epsg:4326"))
```

Quick plot of the points to see their distribution
```{r plot inscriptions without a province}
# base map
plot(provinces$geometry, 
     xlim = c(min(inscriptions_w_occupations$Longitude),
              max(inscriptions_w_occupations$Longitude)),
     ylim = c(min(inscriptions_w_occupations$Latitude),
              max(inscriptions_w_occupations$Latitude)))
# show in red the points not associated with any province
points(unassigned_inscriptions$Longitude,
       unassigned_inscriptions$Latitude,
       col="red")
```

For some of these, this is simply a problem of the precision of the shapefile.
This is the case of inscriptions near the coast or northern border, or for inscriptions on the Balearic islands (which are not part of the shapefile of provinces)
For others, they lie outside of our area of interest and it is not possible to assign them a priori to a province on the basis of this shapefile only.
One needs to deal with these on a case by case scenario, considering the limitations of the data and of the shapefile.

Find the closest province to each unassigned inscription and compute the distance
```{r closest province to each unassigned inscription}
# province index
closest_province_index <- st_nearest_feature(unassigned_inscriptions_sf,provinces)
# assign name of the closest province 
unassigned_inscriptions$closest_province <- provinces$province[closest_province_index]
# compute distance to the closest province
unassigned_inscriptions$distance_to_province <- st_distance(
  unassigned_inscriptions_sf,
  provinces[closest_province_index,],
  by_element = TRUE)
```

Automatically assign a point to a province if the distance is smaller than 50km.
This is a relatively arbitrary threshold, corresponding to the minimal threshold that allows to deal with most of the aforementioned cases of clear lack of assignment while leaving out ambiguous or clearly wrong ones as determined by visual inspection.
```{r assign very close inscriptions to closest province}
inscriptions_in_provinces$province[unassigned_inscriptions_index] <- ifelse(
  unassigned_inscriptions$distance_to_province < set_units(50000,"meters"),
  unassigned_inscriptions$closest_province,
  NA
)
```

Manually assign the case of the Balearic islands
```{r assign Balearic inscriptions to Hispania Citerior}
Balearic_inscriptions_id <- unassigned_inscriptions[unassigned_inscriptions$closest_province=="Hispania Citerior","LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% Balearic_inscriptions_id$`LIST-ID`] <- "Hispania Citerior"
```

Unclear cases beyond the border are manually classified as either "Eastern border" or "North-eastern border", with the exception of the isolated case in Norway, that is dropped. This is debatable, but should have limited impact on the analysis
```{r categorise/clean outlier inscriptions}
# Eastern border
Eastern_inscriptions <- unassigned_inscriptions[unassigned_inscriptions$Longitude > 40,"LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% Eastern_inscriptions$`LIST-ID`] <- "Eastern border"

# update unassigned inscriptions
remaining_unassigned_inscriptions <- inscriptions_w_occupations[which(is.na(inscriptions_in_provinces$province)),]

# North Eastern border
North_easter_inscriptions <- remaining_unassigned_inscriptions[remaining_unassigned_inscriptions$Latitude < 60,"LIST-ID"]
inscriptions_in_provinces$province[inscriptions_in_provinces$`LIST-ID` %in% North_easter_inscriptions$`LIST-ID`] <- "North-eastern border"

# delete outlier
inscriptions_in_provinces <- inscriptions_in_provinces[!is.na(inscriptions_in_provinces$province),]
```

Visual check: represent the inscriptions as points on a map and colour them according to the province they are assigned to.
```{r visualise distribution of inscriptions by province}
# base map
inscriptions_by_province_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = inscriptions_in_provinces,
             aes(color = province)) +
  #geom_point(data = inscriptions_in_provinces,
  #           aes(x = Longitude,
  #               y = Latitude,
  #               color = province)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(inscriptions_in_provinces$Longitude), 
                    max(inscriptions_in_provinces$Longitude)), 
           ylim = c(min(inscriptions_in_provinces$Latitude), 
                    max(inscriptions_in_provinces$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(inscriptions_by_province_plot)
#ggsave("../../figures/economic_complexity/inscriptions_by_province.pdf", inscriptions_by_province_plot, width = 15, height = 5.5)
#ggsave("../../figures/economic_complexity/inscriptions_by_province.jpeg", inscriptions_by_province_plot, width = 15, height = 5.5, dpi = 300)
```

### Epitaphs
The same process is repeated for the epitaphs
```{r}
epitaphs_in_provinces <- st_join(epitaphs_sf, provinces)
# remark: 15 inscriptions fall at the borders between two provinces. For the time being, we assign them at random (may look for the impact of this uncertainty later, but it's likely very small as the counts are large)
epitaphs_in_provinces <- epitaphs_in_provinces[which(!duplicated(epitaphs_in_provinces$`LIST-ID`)),]

epitaphs_in_provinces$Latitude <- epitaphs$Latitude
epitaphs_in_provinces$Longitude <- epitaphs$Longitude
```

Notice that 1657 inscriptions lie outside of the borders of the provinces.
```{r epitaphs without a province}
unassigned_epitaphs_index <- which(is.na(epitaphs_in_provinces$province))
unassigned_epitaphs <- epitaphs[unassigned_epitaphs_index,]
unassigned_epitaphs_sf <- st_as_sf(unassigned_epitaphs,
                                   coords = c("Longitude","Latitude"),
                                   crs = crs("epsg:4326"))
```

We deal with these exactly as above.
```{r find closest province to unassigned epitaphs}
# province index
closest_province_epitaphs_index <- st_nearest_feature(unassigned_epitaphs_sf,provinces)
# assign name of the closest province 
unassigned_epitaphs$closest_province <- provinces$province[closest_province_epitaphs_index]
# compute distance to the closest province (see if the loop is necessary. I put it because otherwise the memory was suffering)
unassigned_epitaphs$distance_to_province <- NA
for (i in 1:nrow(unassigned_epitaphs)) {
  unassigned_epitaphs$distance_to_province[i] <- st_distance(
  unassigned_epitaphs_sf[i,],
  provinces[closest_province_epitaphs_index[i],],
  by_element = TRUE)
  if (!i%%50) print(i) 
}
unassigned_epitaphs$distance_to_province <- set_units(unassigned_epitaphs$distance_to_province,"meters")
```

```{r assign epitaphs to closest province if very close}
epitaphs_in_provinces$province[unassigned_epitaphs_index] <- ifelse(
  unassigned_epitaphs$distance_to_province < set_units(50000,"meters"),
  unassigned_epitaphs$closest_province,
  NA
)
```

```{r manually assign epitaphs in Balearic, Achaia, Sicilia, and Britannia}
# Balearic
Balearic_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Hispania Citerior","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Balearic_epitaphs_id$`LIST-ID`] <- "Hispania Citerior"

# Achaia
Achaia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Achaia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Achaia_epitaphs_id$`LIST-ID`] <- "Achaia"

# Sicila
Sicilia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Sicilia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Sicilia_epitaphs_id$`LIST-ID`] <- "Sicilia"

# Britannia
Britannia_epitaphs_id <- unassigned_epitaphs[unassigned_epitaphs$closest_province=="Britannia","LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Britannia_epitaphs_id$`LIST-ID`] <- "Britannia"
```

THIS CLASSIFICATION  MAY BE DONE MORE CAREFULLY

```{r classify other borders epitaphs}
# Eastern border
Eastern_epitaphs <- unassigned_epitaphs[unassigned_epitaphs$Longitude > 40,"LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% Eastern_epitaphs$`LIST-ID`] <- "Eastern border"

# update unassigned inscriptions
remaining_unassigned_epitaphs <- epitaphs[which(is.na(epitaphs_in_provinces$province)),]

# North Eastern border
North_easter_epitaphs <- remaining_unassigned_epitaphs[remaining_unassigned_epitaphs$Latitude < 50 & remaining_unassigned_epitaphs$Latitude > 42,"LIST-ID"]
epitaphs_in_provinces$province[epitaphs_in_provinces$`LIST-ID` %in% North_easter_epitaphs$`LIST-ID`] <- "North-eastern border"

# Desert outliers to delete
epitaphs_in_provinces <- epitaphs_in_provinces[!is.na(epitaphs_in_provinces$province),]
```

```{r visual check of epitaphs in provinces}
# base map
epitaphs_by_province_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = epitaphs_in_provinces,
             aes(color = province)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(epitaphs_in_provinces$Longitude), 
                    max(epitaphs_in_provinces$Longitude)), 
           ylim = c(min(epitaphs_in_provinces$Latitude), 
                    max(epitaphs_in_provinces$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(epitaphs_by_province_plot)
#ggsave("../../figures/economic_complexity/epitaphs_by_province.pdf", epitaphs_by_province_plot, width = 15, height = 5.5)
#ggsave("../../figures/economic_complexity/epitaphs_by_province.jpeg", epitaphs_by_province_plot, width = 15, height = 5.5, dpi = 300)
```


### Greek inscriptions
The same process is repeated also for the greek inscriptions.
Associate the inscriptions to the province they fall into.
```{r}
greek_inscriptions_in_provinces <- st_join(greek_inscriptions_sf, provinces)
# remark: 6 inscriptions fall on the borders between two provinces. For the time being, we assign them at random (may look for the impact of this uncertainty later, but it's likely very small as the counts are large)
greek_inscriptions_in_provinces <- greek_inscriptions_in_provinces[which(!duplicated(greek_inscriptions_in_provinces$PHI_ID)),]

greek_inscriptions_in_provinces$Latitude <- greek_inscriptions_coordinates$Latitude
greek_inscriptions_in_provinces$Longitude <- greek_inscriptions_coordinates$Longitude
```

Notice that 30945 inscriptions lie outside of the borders of the provinces.
```{r epitaphs without a province}
unassigned_greek_inscriptions_index <- which(is.na(greek_inscriptions_in_provinces$province))
unassigned_greek_inscriptions_sf <- greek_inscriptions_in_provinces[unassigned_greek_inscriptions_index,]
```

We find the distance between these and the closest province.
```{r find closest province to unassigned epitaphs}
# closest province index
unassigned_greek_inscriptions_sf$closest_province_index <- st_nearest_feature(unassigned_greek_inscriptions_sf,
                                                                              provinces) 

# find unique list of locations
unassigned_greek_inscriptions_unique_locations_sf <- unassigned_greek_inscriptions_sf[,c("geometry","closest_province_index")] %>% unique()

# compute distance to the closest province
unassigned_greek_inscriptions_unique_locations_sf$distance_to_province <- st_distance(
  unassigned_greek_inscriptions_unique_locations_sf,
  provinces[unassigned_greek_inscriptions_unique_locations_sf$closest_province_index,],
  by_element = TRUE
)

# transform in df 
unassigned_greek_inscriptions_unique_locations <- unassigned_greek_inscriptions_unique_locations_sf 
unassigned_greek_inscriptions_unique_locations[,c("Longitude","Latitude")] <- st_coordinates(unassigned_greek_inscriptions_unique_locations_sf)
unassigned_greek_inscriptions_unique_locations <- unassigned_greek_inscriptions_unique_locations %>% st_drop_geometry()


# transform in df
unassigned_greek_inscriptions <- unassigned_greek_inscriptions_sf
unassigned_greek_inscriptions[,c("Longitude","Latitude")] <- st_coordinates(unassigned_greek_inscriptions_sf)
unassigned_greek_inscriptions <- unassigned_greek_inscriptions %>% st_drop_geometry()
  
  
# merge info to retrieve full list of unassigned inscriptions with distances to nearest province
unassigned_greek_inscriptions <- unassigned_greek_inscriptions %>% left_join(
  unassigned_greek_inscriptions_unique_locations,
  by = c("Longitude","Latitude","closest_province_index")
)

# retrieve name of the province for greater readability
unassigned_greek_inscriptions$closest_province <-  provinces$province[unassigned_greek_inscriptions$closest_province_index]

```

THIS SECTION HAS TO BE IMPROVED FOR CONSISTENCY WITH THE OTHER ONES.

Assign the province if the distance is less than 100km
```{r assign epitaphs to closest province if very close}
greek_inscriptions_in_provinces$province[unassigned_greek_inscriptions_index] <- ifelse(
  unassigned_greek_inscriptions$distance_to_province < set_units(100000,"meters"),
  unassigned_greek_inscriptions$closest_province,
  NA
)
```

Deal manually with Balearic Islands and Aegean Sea.
These are island regions for which small precision issues may lead to misclassification.
```{r manually assign epitaphs in Balearic, Achaia, Sicilia, and Britannia}
# Balearic
Balearic_greek_inscriptions_id <- unassigned_greek_inscriptions[unassigned_greek_inscriptions$closest_province=="Hispania Citerior","PHI_ID"]
greek_inscriptions_in_provinces$province[greek_inscriptions_in_provinces$PHI_ID %in% Balearic_greek_inscriptions_id$PHI_ID] <- "Hispania Citerior"

# Achaia
Achaia_greek_inscriptions_id <- unassigned_greek_inscriptions[unassigned_greek_inscriptions$closest_province=="Achaia","PHI_ID"]
greek_inscriptions_in_provinces$province[greek_inscriptions_in_provinces$PHI_ID %in% Achaia_greek_inscriptions_id$PHI_ID] <- "Achaia"

# Creta
Creta_greek_inscriptions_id <- unassigned_greek_inscriptions[unassigned_greek_inscriptions$closest_province=="Creta","PHI_ID"]
greek_inscriptions_in_provinces$province[greek_inscriptions_in_provinces$PHI_ID %in% Creta_greek_inscriptions_id$PHI_ID] <- "Creta"

# Asia
Asia_greek_inscriptions_id <- unassigned_greek_inscriptions[unassigned_greek_inscriptions$closest_province=="Asia","PHI_ID"]
greek_inscriptions_in_provinces$province[greek_inscriptions_in_provinces$PHI_ID %in% Asia_greek_inscriptions_id$PHI_ID] <- "Asia"
```

Note that several inscriptions remain unclassified: these lie to the East of the Roman empire, but we deem them too distant to be reasonably associated with specific provinces.

We plot the results:

```{r greek inscriptions by province}
# base map
greek_inscriptions_by_province_plot <- ggplot() +
  # base map
  geom_sf(data = world_no_borders_sf) +
  # add inscriptions
  geom_sf(data = greek_inscriptions_in_provinces,
             aes(color = province)) +
  # define theme, window, and style
  theme_minimal() + 
  coord_sf(xlim = c(min(greek_inscriptions_coordinates$Longitude), 
                    max(greek_inscriptions_coordinates$Longitude)), 
           ylim = c(min(greek_inscriptions_coordinates$Latitude), 
                    max(greek_inscriptions_coordinates$Latitude))) +
  annotation_north_arrow(
    location = "bl", 
    which_north = "true",
    pad_x = unit(0.4, "in"), pad_y = unit(0.4, "in"),
    style = ggspatial::north_arrow_nautical(
      fill = c("grey40", "white"),
      line_col = "grey20",
    )
  ) 

print(greek_inscriptions_by_province_plot)
#ggsave("../../figures/economic_complexity/greek_inscriptions_by_province.pdf", greek_inscriptions_by_province_plot, width = 12, height = 5.5)
#ggsave("../../figures/economic_complexity/greek_inscriptions_by_province.jpeg", greek_inscriptions_by_province_plot, width = 12, height = 5.5, dpi = 300)
```

## Urban inscriptions
Associate each inscription to the closest town in the Pleiades data set
```{r find and associate each inscription to the closest town}
# find closest city
nearest_city_index = st_nearest_feature(inscriptions_w_occupations_sf, cities)

# initialise inscription to closest city sf
inscriptions_in_cities <- cbind(inscriptions_w_occupations_sf,
                                nearest_city_key = cities$Primary.Key[nearest_city_index],
                                nearest_city_ancient_toponym = cities$Ancient.Toponym[nearest_city_index],
                                nearest_city_modern_toponym = cities$Modern.Toponym[nearest_city_index],
                                nearest_city_pop_est = cities$pop_est[nearest_city_index],
                                nearest_city_area = cities$Area[nearest_city_index],
                                inscriptions_coordinates)

# associate the distance
inscriptions_in_cities$distance_to_city <- st_distance(
  inscriptions_in_cities,
  cities[nearest_city_index,],
  by_element = TRUE)
```

Assign an inscription to a city if the distance is below a certain threshold.
First consider the case when the threshold is an arbitrary distance from the city (from very small to max 1h walk) 
```{r assign cities if within a certain arbitrary threshold}
# arbitrary threshold
thresholds <- c(500,1000,2000,5000) #max 1h walking from the centre

# initialise columns
inscriptions_in_cities <- cbind(inscriptions_in_cities,
                                data.frame(matrix(NA,ncol=4)) %>% 
                                  setNames(
                                    paste0("city_",thresholds)
                                    )
                                )

# assign cities only if within a certain threshold
for (t in thresholds){
  inscriptions_in_cities[paste0("city_",t)] <- ifelse(
    inscriptions_in_cities$distance_to_city < set_units(t,"meters"),
    inscriptions_in_cities$nearest_city_key,
    "rural"
  )
}
```

The consider slighly more sophisticated or area-dependent threshold: i.e., a threshold that corresponds to an estimate of the city's radius based on its area.
The area is expressed in hectars in Hanson's database. 
1 hectare is 10000 square meters (i.e., a square 100mx100m).
First, convert the hectar into square meters
Then compute the radius of a circle of a given area using the inverse formula of the area r = sqrt(A/pi).

Remark that when the area is NA, the population is assigned an arbitrary value of 1000. 
For cities with a population of 1000 whose area is indicated, the area is between 1 and 10 hectares, with a mean of approx 6.9 (and similar median of 7). 
Here, the mean value is taken as the radius. 
A sensitivity analysis should follow.

```{r assign city if within an area-dependent threshold}
# average radius for cities with 1000 people
mean_area_1000people <- mean(na.omit(cities$Area[cities$pop_est==1000]))

# define appropriate threshold for each city 
area_based_threshold <- ifelse(
  !is.na(inscriptions_in_cities$nearest_city_area),
  sqrt(inscriptions_in_cities$nearest_city_area*10000/pi),
  sqrt(mean_area_1000people*10000/pi)
)

# assign cities based on area-based threshold
inscriptions_in_cities$city_area_based <- ifelse(
  inscriptions_in_cities$distance_to_city < set_units(area_based_threshold,"meters"),
  inscriptions_in_cities$nearest_city_key,
  "rural"
)
```
 
Hence, one has a classification of the urban occupation-related inscriptions. 
Note that this is a subset of all the occupation-related inscriptions.
```{r county urban inscriptions}
print(
  paste0("Total count of urban inscriptions by threshold. ",
        "Area-adapted threshold: ",
        length(inscriptions_in_cities$city_area_based[!inscriptions_in_cities$city_area_based=="rural"]),
        ", 500m: ",
        length(inscriptions_in_cities$city_500[inscriptions_in_cities$city_500=="rural"]),
        ", 1000m: ",
        length(na.omit(inscriptions_in_cities$city_1000[inscriptions_in_cities$city_1000=="rural"])),
        ", 2000m: ",
        length(na.omit(inscriptions_in_cities$city_2000[inscriptions_in_cities$city_2000=="rural"])),
        ", 5000m: ",
        length(na.omit(inscriptions_in_cities$city_5000[inscriptions_in_cities$city_5000=="rural"]))
  )
)
```

# Table of occupations
## Country
Prepare the data in the correct format by unlisting the occupations in each inscription
```{r unnest the df}
# unnest the df based on the standard names
inscriptions_in_countries_no_Norway_unnested <- unnest(inscriptions_in_countries_no_Norway,"occups_std")
```

Define the row and column names, in this case the countries and the occupations respectively.
```{r country table construction: row and column names}
# col names (occupations, sorted by frequency)
col_names_c <- names(
  sort(
    table(
      inscriptions_in_countries_no_Norway_unnested$occups_std),
    decreasing=TRUE)
  )

# row names (countries, sorted by total counts)
row_names_c <- names(
  sort(
    table(
      inscriptions_in_countries_no_Norway_unnested$country),
    decreasing=TRUE)
  )
```

Then, define the table of frequencies of occupations by country.
```{r country table definition}
# initialisation
country_table <- table(inscriptions_in_countries_no_Norway_unnested$country,
                        inscriptions_in_countries_no_Norway_unnested$occups_std)

# sort based on row and column counts
country_table <- country_table[row_names_c,col_names_c]
```

Represent the table as a heatmap. Note that due to the extreme concentration of inscriptions and occupations in some provinces, here the log of the frequency is shown.
```{r country heatmap}
# Convert the table to a dataframe
country_table_heatmap <- as.data.frame(country_table) %>% setNames(c("country","occupation","frequency"))
country_table_heatmap$log_frequency <- log(country_table_heatmap$frequency)

country_table_heatmap_plot <- ggplot(country_table_heatmap, aes(occupation, country, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "country", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by country") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))
```

Finally, save the results.
```{r save results}
write.csv(country_table,"../../results/economic_complexity/country_table.csv")
ggsave("../../figures/economic_complexity/country_table_heatmap.pdf", country_table_heatmap_plot, width = 15, height = 10)
ggsave("../../figures/economic_complexity/country_table_heatmap.jpeg", country_table_heatmap_plot, width = 15, height = 10, dpi = 300)
```

## Province
Repeat the same process as above for provinces. 
Start by unlisting the occupation data for each inscription
```{r unnest the df}
# unnest the df based on the standard names
inscriptions_in_provinces_unnested <- unnest(inscriptions_in_provinces,"occups_std")
```

Define the row and column names, in this case the provinces and the occupations respectively.
```{r country table construction: row and column names}
# col names (occupations, sorted by frequency)
col_names_p <- names(
  sort(
    table(
      inscriptions_in_provinces_unnested$occups_std),
    decreasing=TRUE)
  )

# row names (countries, sorted by total counts)
row_names_p <- names(
  sort(
    table(
      inscriptions_in_provinces_unnested$province),
    decreasing=TRUE)
  )
```

Define the frequency table of occupations by province.
```{r country table definition}
# initialisation
province_table <- table(inscriptions_in_provinces_unnested$province,
                        inscriptions_in_provinces_unnested$occups_std)

# sort based on row and column counts
province_table <- province_table[row_names_p,col_names_p]
```

Represent the table as a heatmap. Note that due to the extreme concentration of inscriptions and occupations in some provinces, here the log of the frequency is shown.
```{r province heatmap}
province_table_heatmap <- as.data.frame(province_table) %>% setNames(c("province","occupation","frequency"))
province_table_heatmap$log_frequency <- log(province_table_heatmap$frequency)

province_table_heatmap_plot <- ggplot(province_table_heatmap, aes(occupation, province, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "province", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by province") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))

print(province_table_heatmap_plot)
```

Finally, save the results
```{r save results}
write.csv(province_table,"../../results/economic_complexity/province_table.csv")
ggsave("../../figures/economic_complexity/province_table_heatmap.pdf", province_table_heatmap_plot, width = 15, height = 10)
ggsave("../../figures/economic_complexity/province_table_heatmap.jpeg", province_table_heatmap_plot, width = 15, height = 10, dpi = 300)
```

## Cities
For the cities, one needs to deal with the different radii used in assigning an inscription to a city. Use a function for conciseness.
```{r function to plot occupation structure based on threshold}
cities_table_heapmap_by_threshold <- function(t){
  if (!t %in% c(thresholds,"area_based")){
    stop("The threshold value must '500', '1000', '2000', '5000' or 'area_based'",
         call. = F)
  }
  
  # select column depending on threshold choice
  city_col <- paste0("city_",t)
  # exclude rural inscriptions
  inscriptions_in_cities_no_rural <- inscriptions_in_cities[!inscriptions_in_cities[[city_col]]=="rural",]
  # unnest the list
  inscriptions_in_cities_unnested <- unnest(inscriptions_in_cities_no_rural,"occups_std")

  # col names (occupations, sorted by frequency)
  col_names_c <- names(
  sort(
    table(
      inscriptions_in_cities_unnested$occups_std),
    decreasing=TRUE)
  )

  # row names (countries, sorted by total counts)
  row_names_c <- names(
  sort(
    table(
      inscriptions_in_cities_unnested[[city_col]]),
    decreasing=TRUE)
  )
  
  # define table
  # initialisation
  cities_table <- table(inscriptions_in_cities_unnested[[city_col]],
                        inscriptions_in_cities_unnested$occups_std)

  # sort based on row and column counts
  cities_table <- cities_table[row_names_c,col_names_c]
  
  # heatmap
  cities_table_heatmap <- as.data.frame(cities_table) %>% setNames(c("city_ID","occupation","frequency"))
  cities_table_heatmap$log_frequency <- log(cities_table_heatmap$frequency)
  cities_table_heatmap <- left_join(cities_table_heatmap,
                                    cities[,c("Primary.Key","Ancient.Toponym")],
                                    by = join_by(city_ID==Primary.Key)) %>%
    setNames(c("city_ID","occupation","frequency","log_frequency","ancient_toponym","geometry")) 
    
  cities_table_heatmap$city_ID <- factor(cities_table_heatmap$city_ID, 
                                 row_names_c)
  cities_table_heatmap$occupation <- factor(cities_table_heatmap$occupation, 
                                 col_names_c)
  
  heatmap_plot <- ggplot(cities_table_heatmap, aes(occupation, city_ID, fill=log_frequency)) + 
    geom_tile() +
    scale_fill_gradient(low = "white", high = "red") +
    labs(x = "occupation", 
         y = "city ID", 
         fill ="log(frequency)",
         title = paste0("Frequency of occupations in inscriptions by city. Threshold: ",t)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2),
          axis.text.y = element_text(size = 2))
  
  # save results
  write.csv(cities_table,paste0("../../results/economic_complexity/cities_table_threshold_",t,".csv"))
  ggsave(paste0("../../figures/economic_complexity/heatmap_cities_",t,".pdf"), heatmap_plot, width = 15, height = 10)
  ggsave(paste0("../../figures/economic_complexity/heatmap_cities_",t,".jpeg"), heatmap_plot, width = 15, height = 10, dpi = 300)
  
  # visualise them
  print(heatmap_plot)
  return(cities_table)
}
```

Run the function to output and save the results.
```{r run the above function}
cities_table_list <- list()
for (t in c(thresholds,"area_based")) {
  cities_table_t <- cities_table_heapmap_by_threshold(t)
  cities_table_list <- append(cities_table_list,
                              cities_table_t)
}
```

# Uncertainty and biases TO DO
## Uncertainty intro
The above tables were constructed by using the occupation data as it was directly extracted from the inscriptions. 

However, inscriptions do not represent a realistic view of the real occupational structure. Sources of bias include:
* Gender bias: inscriptions in general contain information about men than women. 
* Research bias: uneven research interest in different occupations and geographical areas, imperfect detection method, etc. 
* Occupation bias: some occupations are systematically underreported (e.g., farmers)
* Language bias: the dataset includes only latin inscriptions, but a large number of inscriptions were written in Greek, especially in the Eastern side of the Roman empire. 

In this section we propose to systematically address these biases with the aim to reach more accurate estimates of the real distribution of occupations.

We do this by constructing functions to each source of bias.

## Functions to address bias TO DO
### Gender bias ONGOING Â¨
We multiply women-only occupations (which for simplicity we take to be those with female-only names), by a corrective factor, derived from the men/women ratio in funerary inscriptions. 

```{r extract info about gender inscriptions}
# compute a table of frequency of gender from funerary inscriptions
EDH_epitaphs <- EDH_people[EDH_people$type_of_inscription_clean=="epitaph",]
EDH_gender <- table(EDH_epitaphs$gender)
EDH_gender_NA <- sum(is.na(EDH_epitaphs$gender))
print(EDH_gender)
print(paste("NA values:", EDH_gender_NA))

# select female occupations
occupations_female <- occupations_all$std_spelling[occupations_all$gender=="female"]
```

Gender is specified as "female", "male", but also uncertain but probably male "M?", uncertain but probably female "W?", and undefined (NA). We account for this in the definition of the ratio.
```{r compute the men/women ratio in funerary inscriptions}
gender_ratio_simple <- as.numeric(EDH_gender["male"]/EDH_gender["female"])
gender_ratio_max <- (EDH_gender[["male"]]+EDH_gender[["M?"]]+EDH_gender[["W?"]]+EDH_gender_NA)/EDH_gender[["female"]]
gender_ratio_min <- EDH_gender[["male"]]/(EDH_gender[["female"]]+EDH_gender[["M?"]]+EDH_gender[["W?"]]+EDH_gender_NA)
```

Randomly generate bias correction values based on a triangular distribution with range (gender_ratio_min,gender_ratio_max) and peak at gender_ratio_simple.

```{r vector of gender ratio bias}
# randomly generate the vector according to a triangular distribution
gender_ratio_v <- rtri(n = 1000,
                       min = gender_ratio_min,
                       max = gender_ratio_max,
                       mode = gender_ratio_simple)

# visual check of the distribution of the results
plot(hist(gender_ratio_v,20))
```

```{r gender bias function}
gender_bias <- function(table, bias){
  # update columns with female occupations
  table[,colnames(table)%in%occupations_female] <- bias*table[,colnames(table)%in%occupations_female] 
  return(table)
}
```


### Research bias ONGOING
#### Estimate population by geographical unit
##### Notes on population estimation
To establish which geographical units are overrepresented in inscriptions, we can use the ratio between funerary inscriptions and the total number of people who lived/died in that geographical unit while it was part of the Roman Empire. 
The assumption is that deaths happen (theoretically) proportionally to the population.

To do this, we need to estimate the total population residing in each geographical unit and how it changed in time.
Doing this carefully would require much more information than what is available. 
What we present here a simplified approach that is only based on peak population estimates available from the literature.

As far as we know, there are no estimates of the Ancient Roman population at the provincial level (and certainly not within the borders of modern nations or town hinterlands).
Instead, a set of estimates exist for the population in 10 macroregions of the Empire (Table 3.1 in "Scheidel W. Demography. In: Scheidel W, Morris I, Saller RP, eds. The Cambridge Economic History of the Greco-Roman World. Cambridge University Press; 2007:38-86") and for the population of individual urban units (Hanson).

For each macroregion, we compute the (peak) urban population by summing the population estimates of all the urban areas falling within it.
We subtract the urban population to obtain an estimate of the rural population in the macroregion. 

To each province in the macroregion, we find the urban population by summing the population estimates of the urban areas falling within it. We find the rural population by taking a part of the rural population of the macroregion, proportionate to the area of the province.
Note that this is the same as assuming that the rural population density is approximately constant within a macroregion. This is a crude assumption, but the most natural one that can be made with limited data and without additional population models. In the future, it can be improved by integrating additional information (e.g., terrain and suitability to agriculture).

To estimate population in each year before and after the peak assume naively a constant annual population growth/decline rate r. We take r distributed according to a triangular distribution between 0 and 0.5%, with a peak at 0.15%, following Hanson's estimates for urban population (Hanson, J., 2021. New approaches to the urban population and urbanization rate of the Roman Empire, AD 1 to 200.). We compute the 





RK: This is a very simplified method.

##### Provinces
First, associate each province to the macroregion mentioned by Scheidel.
```{r assign each province to its macroregion}
provinces_macroregions_list <- list(
  Italy_and_islands = c(
    "Aemilia (Regio VIII)",
    "Apulia et Calabria (Regio II)",
    "Bruttium et Lucania (Regio III)",
    "Corsica",
    "Etruria (Regio VII)",
    "Latium et Campania (Regio I)",
    "Liguria (Regio IX)",
    "Picenum (Regio V)",
    "Samnium (Regio IV)",
    "Sardinia",
    "Sicilia",
    "Transpadana (Regio XI)",
    "Umbria (Regio VI)",
    "Venetia et Histria (Regio X)"
  ),
  Iberia = c(
    "Baetica",
    "Hispania Citerior",
    "Lusitania"
    ),
  Gaul_and_Germany = c(
    "Alpes Cottiae",
    "Alpes Graiae",
    "Alpes Maritimae",
    "Alpes Poeninae",
    "Aquitania",
    "Belgica",
    "Germania Inferior",
    "Germania Superior",
    "Lugdunensis",
    "Narbonensis",
    "Raetia"
    ),
  Britain = c(
    "Britannia"
    ),
  Danubian_region = c(
    "Dacia",
    "Dalmatia",
    "Moesia Inferior",
    "Moesia Superior",
    "Noricum",
    "Pannonia Inferior",
    "Pannonia Superior"
    ),
  Greek_peninsula = c(
    "Achaia",
    "Creta",
    "Epirus",
    "Macedonia",
    "Thracia"
    ),
  Anatolia = c(
    "Asia",
    "Bithynia et Pontus",
    "Cappadocia",
    "Cilicia",
    "Lycia et Pamphylia",
    "Galatia"
    ),
  Greater_Syria = c(
    "Arabia",
    "Cyprus",
    "Iudaea",
    "Syria"
    ),
  Egypt = c(
    "Aegyptus"
    ),
  North_Africa = c(
    "Africa Proconsularis",
    "Cyrene",
    "Mauretania Caesariensis",
    "Mauretania Tingitana",
    "Numidia")
)

# transform to dataframe
provinces_macroregions_df<-data.frame(unlist(provinces_macroregions_list)) %>% setNames("province")
provinces_macroregions_df$macroregion <- provinces_macroregions_df %>% rownames() %>% str_remove_all("[0-9]") %>% str_replace_all("_"," ")
rownames(provinces_macroregions_df) <- NULL
```

Compute the area of each province, and the area of each macroregion
```{r areas of provinces and macroregions}
# areas of the provinces
provinces_areas_df <- data.frame(province = provinces$province,
                                 area = st_area(provinces))

provinces_macroregions_areas_df <- left_join(provinces_macroregions_df,
                                       provinces_areas_df)

# areas of the macroregions
macroregions_areas_df <- provinces_macroregions_areas_df %>%
  group_by(macroregion) %>%
  summarize(macroregion_area = sum(area))
```

Find the proportion of the area of each macroregion falling in a specific province
```{r province area/macroregion area}
# add to the province and macroregions df the areas of the macroregions
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_areas_df,
  macroregions_areas_df,
  by = join_by(macroregion))

# find the proportion of the macroregion's area falling in each province
provinces_macroregions_full_info_df$area_proportion <- as.numeric(
  provinces_macroregions_full_info_df$area/provinces_macroregions_full_info_df$macroregion_area)
```

Create an sf object of the macroregions DOES NOT WORK
```{r macroregions sf SKIP}
# associate macroregions to provinces in the sf
#provinces_macroregions <- left_join(provinces,
#                                    provinces_macroregions_df)

# unite macroregions
#macroregions <- provinces_macroregions %>%
#  group_by(macroregion) %>%
#  summarize() %>%
#  st_union()

#st_write(macroregions,"C:/Users/au732923/OneDrive - Aarhus Universitet/Desktop/macroregions.shp")
```

Compute the urban population for each province.
```{r urban population by province}
# assign each city to its closest province 
# RK: the province may differ from those used by Hanson, and we need this step to ensure consistency.
closest_province_to_city_index <- st_nearest_feature(cities,provinces)
cities_in_provinces_df <- data.frame(
  Primary.Key = cities$Primary.Key,
  Ancient.Toponym = cities$Ancient.Toponym,
  pop_est = cities$pop_est,
  province = provinces$province[closest_province_to_city_index]
  )

# compute the urban population by province
province_urban_population_df <- cities_in_provinces_df %>%
  group_by(province) %>%
  summarize(urban_pop = sum(pop_est)) 
```

If there are provinces without cities, assign population 0.
This is actualy the case of the Alpes Graiae. 
```{r provinces without cities}
# add a row with value 0 
province_urban_population_df <- rbind(
  province_urban_population_df,
  data.frame(
    province = provinces$province[
      which(!provinces$province %in%
              province_urban_population_df$province)],
    urban_pop = 0
    )
)

# sort alphabetically
province_urban_population_df <- province_urban_population_df[order(province_urban_population_df$province),]
```

Finally compute the urban population by macroregion.
```{r urban population by macroregion}
# urban population of the macroregions
macroregions_urban_population_df <- province_urban_population_df %>%
  left_join(provinces_macroregions_areas_df) %>%
  group_by(macroregion) %>%
  summarize(urban_pop = sum(urban_pop))

#RK: HANSON'S CITY POPULATION DATA SHOULD CONTAIN MORE INFO ON THE INHERENT UNCERTAINTY
```

Then digitise the total population estimates for each macroregion.
```{r manually encode population estimates for the macroregions}
# Data based on "Scheidel W. Demography. In: Scheidel W, Morris I, Saller RP, eds. The Cambridge Economic History of the Greco-Roman World. Cambridge University Press; 2007:38-86." Table 3.1
macroregion_pop_165AD_df <- data.frame(
  macroregion = c("Italy and islands", 
                  "Iberia", 
                  "Gaul and Germany",
                  "Britain",
                  "Danubian region",
                  "Greek peninsula",
                  "Anatolia",
                  "Greater Syria",
                  "Egypt",
                  "North Africa"),
  tot_pop_min = c(12000000,
                  7000000,
                  9000000,
                  1500000,
                  5000000,
                  2500000,
                  9000000,
                  5000000,
                  5000000,
                  7000000),
  tot_pop_max = c(13000000,
                  9000000,
                  12000000,
                  2000000,
                  6000000,
                  3000000,
                  10000000,
                  6000000,
                  6000000,
                  8000000))
```

It is easy to have estimates of the rural population of each macroregion by subtracting the urban population from the estimates of the urban population.
```{r total, rural urban and rural population of the macroregions}
# total and urban population 
macroregion_pop_165AD_rural_urban_df <- left_join(
  macroregion_pop_165AD_df,
  macroregions_urban_population_df)

# rural population
macroregion_pop_165AD_rural_urban_df$rural_pop_min <- macroregion_pop_165AD_rural_urban_df$tot_pop_min - macroregion_pop_165AD_rural_urban_df$urban_pop
macroregion_pop_165AD_rural_urban_df$rural_pop_max <- 
macroregion_pop_165AD_rural_urban_df$tot_pop_max - macroregion_pop_165AD_rural_urban_df$urban_pop
```

To estimate the rural population in each province, we distribute the rural population living in each macroregion amongst the provinces that form it, proportionately to their area.
```{r urban, rural and total population by province}
# add the province's urban population to the full info df
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_full_info_df,
  province_urban_population_df
)

# add the populations of the macroregion
provinces_macroregions_full_info_df <- left_join(
  provinces_macroregions_full_info_df,
  # add prefix macroregion to the column names to avoid confusion
  macroregion_pop_165AD_rural_urban_df %>% 
    setNames(c("macroregion",
               paste0(
                 "macroregion_",
                 colnames(macroregion_pop_165AD_rural_urban_df)[-1])))
)

# add the rural population proportionately to the area of the province
provinces_macroregions_full_info_df$rural_pop_max <- 
  provinces_macroregions_full_info_df$macroregion_rural_pop_max*provinces_macroregions_full_info_df$area_proportion
provinces_macroregions_full_info_df$rural_pop_min <- 
  provinces_macroregions_full_info_df$macroregion_rural_pop_min*provinces_macroregions_full_info_df$area_proportion

# compute the min/max total population for each province
provinces_macroregions_full_info_df$tot_pop_min <- provinces_macroregions_full_info_df$urban_pop+
  provinces_macroregions_full_info_df$rural_pop_min
provinces_macroregions_full_info_df$tot_pop_max <- provinces_macroregions_full_info_df$urban_pop+
  provinces_macroregions_full_info_df$rural_pop_max
```

Check that total values of the estimates make sense
```{r check total population in macroregion}
# compare these two data frames with the population in macroregion_pop_165AD_df
provinces_macroregions_full_info_df %>% group_by(macroregion) %>%
  summarize(pop = sum(tot_pop_min))
provinces_macroregions_full_info_df %>% group_by(macroregion) %>%
  summarize(pop = sum(tot_pop_max))
```

Extract only population info per each province
```{r select population columns from full info df}
provinces_population_df <-
  provinces_macroregions_full_info_df[,c("province",
    "urban_pop",
    "rural_pop_min",
    "rural_pop_max",
    "tot_pop_min",
    "tot_pop_max")]
```

Finally save these results.
```{r save population by province as csv}
#write.csv(provinces_macroregions_full_info_df,
#          "../../results/economic_complexity/provinces_macroregions_full_info.csv")
#write.csv(provinces_population_df,
#          "../../results/economic_complexity/provinces_population.csv")

```

##### Countries
We perform a similar operation to estimate the urban and rural population who lived within the borders of modern day countries.
We estimate the urban population using Hanson's dataset. 
We estimate the rural population by distributing the above estimates of rural populations proportionately to the percentage of area of a province falling in each country.
E.g. The province "Sicilia" falls 100% within the modern country of Italy, hence we assign all of Sicilia's rural population to Italy.
Instead if another province falls 50% in in a country and 50% in another country, we assign half of the province's rural population to the each country. (NEED TO FIND A CONCRETE EXAMPLE)
```{r country and provinces sf}
# add area info to countries
world_sf$area <- st_area(world_sf)

# find intersections between the two shapefiles of modern day countries and provinces
intersections <- st_intersection(world_sf,provinces) %>%
  dplyr::select(c("iso3","area","province","geometry")) %>% # select only needed columns
  setNames(c("country","country_area","province","geometry"))
```

Compute the area of the intersections
```{r country and provinces areas}
# calculate the area of each intersection
intersections$intersection_area <- st_area(intersections)

# save info in a dataframe for easier retrival
intersections_df <- st_drop_geometry(intersections)

# add ID columns
intersections_df$intersection_ID <- paste(
  1:nrow(intersections_df),
  intersections_df$country,
  intersections_df$province ) %>% 
  str_replace_all(" ","_")

# place ID column as first one
intersections_df <- intersections_df[,c("intersection_ID","country","province","country_area","intersection_area")]
```

Note that due to small differences between the shapefiles of the countries and the provinces, the sum of the areas of the intersections falling within a given province is not exactly equal to that of the province itself.
```{r corrective factors for areas}
# compute the sum of the areas of the intersections
check_areas_intersections_df <- intersections_df %>%
  group_by(province) %>%
  summarize(sum_intersection_areas = sum (intersection_area)) %>% 
  left_join(provinces_areas_df)

# compare the sum of the areas of the intersections with the area of the province 
check_areas_intersections_df$area_correction_factor <- check_areas_intersections_df$sum_intersection_areas/check_areas_intersections_df$area
```

From now on, we use this total intersection area as our province area to avoid complications.
Compute the proportion of each province's total area (or, more precisely, of the sum of the intersections) fell in each intersection. 
```{r proportion of area by intersection}
# add sum of the areas of the intersections to the df of intersections
intersections_df <- left_join(
  intersections_df,
  check_areas_intersections_df[c("province","sum_intersection_areas")]
  )

# compute the proportion by dividing the areas
intersections_df$prop_intersection_area <- intersections_df$intersection_area/intersections_df$sum_intersection_areas
```

Now to estimate the rural population of each intersection, take the rural population of the province it belongs to and multiply by the proportion of the total area of the province (or more precisely of the sum of the intersections belonging to the province) that falls within the intersection.
```{r rural population of intersections}
# merge info on intersections and rural population of the provinces
intersections_pop_full_info_df <- left_join(
  intersections_df[c("intersection_ID","country","province","prop_intersection_area")],
  provinces_population_df[c("province","rural_pop_min","rural_pop_max")]) %>% setNames(c("intersection_ID","country","province","prop_intersection_area","province_rural_pop_min","province_rural_pop_max"))


# compute estimates of rural population of intersections
intersections_pop_full_info_df$intersection_rural_pop_min <- as.numeric(intersections_pop_full_info_df$province_rural_pop_min*intersections_pop_full_info_df$prop_intersection_area)
intersections_pop_full_info_df$intersection_rural_pop_max <- as.numeric(intersections_pop_full_info_df$province_rural_pop_max*intersections_pop_full_info_df$prop_intersection_area)
```

Now compute the urban population of each intersection starting from Hanson's dataset.
```{r urban population by intersection}
# assign each city to its closest intersection
closest_intersection_to_city_index <- st_nearest_feature(cities,intersections)
cities_in_intersections_df <- data.frame(
  Primary.Key = cities$Primary.Key,
  Ancient.Toponym = cities$Ancient.Toponym,
  pop_est = cities$pop_est,
  intersection_ID = intersections_df$intersection_ID[closest_intersection_to_city_index]
)

# compute the urban population by intersection
intersections_urban_population_df <- cities_in_intersections_df %>%
  group_by(intersection_ID) %>%
  summarize(intersection_urban_pop = sum(pop_est)) 
```

If there are intersections without cities, assign population 0.
```{r intersections without cities}
# add a row with value 0 
intersections_urban_population_df <- rbind(
  intersections_urban_population_df,
  data.frame(
    intersection_ID = intersections_df$intersection_ID[
      which(!intersections_df$intersection_ID %in%
              intersections_urban_population_df$intersection_ID)],
    intersection_urban_pop = 0
    )
)

# sort alphabetically
intersections_urban_population_df <- intersections_urban_population_df[order(intersections_urban_population_df$intersection_ID),]
```

Add this info to the df of intersections' populations
```{r urban, rural and total population of intersections}
# urban population
intersections_pop_full_info_df <- left_join(intersections_pop_full_info_df,
                                            intersections_urban_population_df)

# total population
intersections_pop_full_info_df$intersection_tot_pop_min <- 
intersections_pop_full_info_df$intersection_rural_pop_min + 
intersections_pop_full_info_df$intersection_urban_pop
intersections_pop_full_info_df$intersection_tot_pop_max <-
  intersections_pop_full_info_df$intersection_rural_pop_max + 
intersections_pop_full_info_df$intersection_urban_pop
```

Check the dataset for consistency: RK THIS ALMOST WORKS BUT NOT QUITE
Remark: the match is not perfect: there must be a city that is classifies as closer to Achaia than Asia once the intersections are taken. This should not be a huge problem in principle as the difference is small. But it is worth to take it under consideration.
```{r check that the total for the provinces almost matches}
intersections_pop_full_info_df %>% 
  group_by(province) %>%
  summarize(preliminary_sum_min=sum(intersection_tot_pop_max))  %>%
  left_join(
    provinces_macroregions_full_info_df[c("province","tot_pop_max","tot_pop_min")]
  )
```

Finally, group the intersections by country and save the population data
```{r group the intersections by country and save the population data}
# compute the population
countries_population_df <-  intersections_pop_full_info_df %>% 
  group_by(country) %>% 
  summarize(urban_pop= sum(intersection_urban_pop),
            rural_pop_min = sum(intersection_rural_pop_min),
            rural_pop_max = sum(intersection_rural_pop_max),
            tot_pop_min = sum(intersection_tot_pop_min),
            tot_pop_max = sum(intersection_tot_pop_max))

# check validity of grand total
(sum(provinces_macroregions_full_info_df$tot_pop_min) == sum(countries_population_df$tot_pop_min) && sum(provinces_macroregions_full_info_df$tot_pop_max) == sum(countries_population_df$tot_pop_max)) 

# save results
#write.csv(countries_population_df,
#          "../../results/economic_complexity/countries_population.csv")
#write.csv(intersections_pop_full_info_df,
#          "../../results/economic_complexity/intersections_population_full_info.csv")
```

##### Total number of deaths in each province
The above population estimates for the geographical units refer to peak population. We now use them to estimate how many people have died whilst the province was part of the Roman empire
```{r construct total population estimates for each province}
# read csv with info on when provinces were conquered/lost
province_dates_df <- read.csv("../../data/economic_complexity/province_dates.csv",sep=";")

# order alphabetically
provinces_population_df <- provinces_population_df[order(provinces_population_df$province),]
province_dates_df <- province_dates_df[order(province_dates_df$province),]

# build data.frame of population multipliers
n_iter <- 1000
years <- c(min(province_dates_df$start_date):-1,1:max(province_dates_df$end_date))
n_years <- abs(min(province_dates_df$start_date)) + max(province_dates_df$end_date)

# extract the growth rates from a triangular distribution 
growth_rate_samples <- rtri(n_iter,min=0,max=0.005,mode=0.0015)

# define the population functions
integrand_to_165AD <- function(x){(1-r)^(165-x)}
integrand_from_165AD <- function(x){(1-r)^(x-165)}

# initialise population results
provinces_total_population_df <- data.frame(
  iter = rep(1:n_iter, each = nrow(provinces_population_df)),
  province = rep(provinces_population_df$province,n_iter),
  urb_pop_grand_total = 0,
  rural_pop_min_grand_total = 0,
  rural_pop_max_grand_total = 0,
  tot_pop_min_grand_total = 0,
  tot_pop_max_grand_total = 0)

for (i in 1:n_iter) {
  r <- growth_rate_samples[i]
  for (j in 1:nrow(province_dates_df)){
    # find the start and end date of each province (THIS SHOULD BE DONE WITH VECTORS IN THE FUTURE)
    start_date <- province_dates_df$start_date[j]
    end_date <- province_dates_df$end_date[j]
    
    # find integral
    integral_to_165AD <- integrate(integrand_to_165AD,start_date,min(end_date,165))
    integral_from_165AD <- integrate(integrand_to_165AD,max(start_date,165),end_date)
    integral_total <- integral_to_165AD$value + integral_from_165AD$value

    # add values to df
    provinces_total_population_df[(i-1)*nrow(provinces_population_df)+j,
                                  c("urb_pop_grand_total",
                                    "rural_pop_min_grand_total",
                                    "rural_pop_max_grand_total",
                                    "tot_pop_min_grand_total",
                                    "tot_pop_max_grand_total")] <-
      integral_total*provinces_population_df[j,c("urban_pop","rural_pop_min","rural_pop_max","tot_pop_min","tot_pop_max")]
  }
  print(i)
}

# 
r <- 0.0015


```





We use them to construct estimates of how many peopleyears 
```{r}
```


#### Ratios population/epitaph TO REDO WITH UPDATED COUNTS GIVEN THE LANGUAGE
First, compute the ratios of the people per epitaph
```{r population/epitaph by country}
# countries
# count epitaphs by country
epitaphs_in_countries_counts <- epitaphs_in_countries$country %>% 
  table() %>%
  as.data.frame() %>%
  setNames(c("country","epitaphs"))

# initialise data frame of bias 
ratio_epitaphs_pop_countries <- data.frame(
  country = row_names_c) %>% 
  left_join(countries_population_df[,c("country","tot_pop_min","tot_pop_max")]) %>%
  left_join(epitaphs_in_countries_counts)

# add columns of ratios between population estimates and epitaphs counts
ratio_epitaphs_pop_countries$people_per_epitaph_min <- ratio_epitaphs_pop_countries$tot_pop_min/ratio_epitaphs_pop_countries$epitaphs
ratio_epitaphs_pop_countries$people_per_epitaph_max <- ratio_epitaphs_pop_countries$tot_pop_max/ratio_epitaphs_pop_countries$epitaphs

# note that Georgia has no population data (as a result of the intersection with the provinces) and no epitaphs
#row_names_c[which(!row_names_c%in%unique(epitaphs_in_countries$country))]

# hence we artificially assign to it the ratio across the data set
ratio_epitaphs_pop_countries[ratio_epitaphs_pop_countries$country=="GEO","people_per_epitaph_min"] <-
  sum(countries_population_df$tot_pop_min)/nrow(epitaphs_in_countries)
ratio_epitaphs_pop_countries[ratio_epitaphs_pop_countries$country=="GEO","people_per_epitaph_max"] <-
  sum(countries_population_df$tot_pop_max)/nrow(epitaphs_in_countries)
```

Repeat the same for provinces.
```{r population/epitaph by province}
# province
# count epitaphs by province
epitaphs_in_provinces_counts <- epitaphs_in_provinces$province %>% 
  table() %>%
  as.data.frame() %>%
  setNames(c("province","epitaphs"))

# initialise data frame of bias 
ratio_epitaphs_pop_provinces <- data.frame(
  province = row_names_p) %>% 
  left_join(provinces_population_df[,c("province","tot_pop_min","tot_pop_max")]) %>%
  left_join(epitaphs_in_provinces_counts)

# add columns of ratios between population estimates and epitaphs counts
ratio_epitaphs_pop_provinces$people_per_epitaph_min <- ratio_epitaphs_pop_provinces$tot_pop_min/ratio_epitaphs_pop_provinces$epitaphs
ratio_epitaphs_pop_provinces$people_per_epitaph_max <- ratio_epitaphs_pop_provinces$tot_pop_max/ratio_epitaphs_pop_provinces$epitaphs

# for the Eastern and North-Eastern border we do not have estimates. For now we assign the average (we might have to delete them from the tables)
ratio_epitaphs_pop_provinces[ratio_epitaphs_pop_provinces$province %in% c("Eastern border","North-eastern border"),
                        "people_per_epitaph_min"] <-
  sum(provinces_population_df$tot_pop_min)/nrow(epitaphs_in_provinces)
ratio_epitaphs_pop_provinces[ratio_epitaphs_pop_provinces$province %in% c("Eastern border","North-eastern border"),"people_per_epitaph_max"] <-
  sum(provinces_population_df$tot_pop_max)/nrow(epitaphs_in_provinces)

```

Now, save the results BUT NOTE THAT THEY WILL HAVE TO BE REVIEWED
```{r save results}
# save results
write.csv(ratio_epitaphs_pop_countries,
          "../../results/economic_complexity/ratio_epitaphs_pop_countries.csv")
write.csv(ratio_epitaphs_pop_provinces,
          "../../results/economic_complexity/ratio_epitaphs_pop_provinces.csv")
```

### Farmers OK
The Roman Empire was primarily a rural society.
Our above estimates indicate that the rural population would have comprised roughly between 84% and 86% of the total population, though this varies widely among regions.
Most of these people would have been involved in agriculture, but evidence of farming as an occupation in inscriptions is extremely scarce (only 7 references in the whole empire).

We conclude our attempt to reduce bias in the tables by inflating the count of the generic profession of farmer (agricola).
We assume for simplicity that generic agricolae and other food-production-related occupations would involve a proportion of the total occupations roughly similar to that of the rural population.
(Rk: in practice there would be a certain proportion of rural population not involved in agriculture and a certain proportion of urban population involved in it. For now we make the simplifying assumption that these would roughly cancel each other off).

Let "a" be the number of "agricola"
Let "f" be the count of people involved in other "food-production" activities (based on Harris category).
Let "d" be the sum of all occupations different from food production.
Let "r" be the proportion rural population in a geographical unit.
Let "p" be a parameter, with p very close to 1.

Then the above assumption translates into the following simple equation: a+f = pr(a+f+d),
which yields a = dpr/(1-pr)-f.
RK: when p=1, 1-pr=u, where u is the urban population, so a=dr/u-f

```{r function to expand the count of "agricola" in the table}
all_food_prod_occs <- occupations_status$std_spelling[occupations_status$Harris_Category=="Food-Production"]
other_food_prof_occ <- all_food_prod_occs[!all_food_prod_occs=="agricola"]
non_food_prod_occ <- occupations_status$std_spelling[!occupations_status$std_spelling %in% all_food_prod_occs]

# need to eliminate eastern and north eastern border from the computation
#a<-a[!rownames(a)%in%c("Eastern border","North-eastern border"),]

# ensure parameter p is always slightly below 1 (otherwise divide by inf, but it makes sense logically)
agricola_correction <- function(occupation_table, p){
  # find names of geographical units
  gu <- rownames(occupation_table)
  
  # initialise the outputs: two output tables, one with the minimum and one with the maximum estimates
  output_table_min <- occupation_table
  output_table_max <- occupation_table
  
  # define the equation variables
  f <- rowSums(occupation_table[,other_food_prof_occ])
  d <- rowSums(occupation_table[,non_food_prod_occ])
  
  # info on population
  pop <- provinces_population_df
  rownames(pop) <- provinces_population_df$province
  pop <- pop[gu,]
  
  r_min <- pop[gu,"rural_pop_min"]/pop[gu,"tot_pop_min"]
  r_max <- pop[gu,"rural_pop_max"]/pop[gu,"tot_pop_max"]
  a_min <- apply(cbind(d*p*r_min/(1-p*r_min)-f,occupation_table[,"agricola"]),1,max) # to ensure that we do not go below what is recorded
  a_max <- apply(cbind(d*p*r_max/(1-p*r_max)-f,occupation_table[,"agricola"]),1,max) # to ensure that we do not go below what is recorded

  # update tables
  output_table_min[,"agricola"] <- a_min
  output_table_max[,"agricola"] <- a_max
  
  # sort
  # col names (occupations, sorted by frequency)
  col_names_min <- names(
    sort(
      colSums(output_table_min),
      decreasing=TRUE)
    )
   col_names_max <- names(
    sort(
      colSums(output_table_max),
      decreasing=TRUE)
    )
  # row names (geographical units, sorted by total counts)
  row_names_min <- names(
    sort(
      rowSums(output_table_min),
      decreasing=TRUE)
    )
   row_names_max <- names(
    sort(
      rowSums(output_table_max),
      decreasing=TRUE)
    )
   # apply sorting
  output_table_min <- output_table_min[row_names_min,col_names_min]
  output_table_max <- output_table_max[row_names_max,col_names_max]

  #output as list
  output_table_list = list(min = output_table_min, 
                           max = output_table_max)
}
```

### Social status
#### Summary
Roughly speaking, higher status people tend to be over-represented compared to lower status people in inscriptions.
As certain occupations were primarily performed by people of high or low status, the disparity in representation affects occupation counts.
In this section, we propose a simple (and improvable) mechanism to address this bias.

Among all inscriptions with occupations, we select those included in EDH and that thus contain references to people. 
Among these, we focus on those that contain references to the people's status. 
We distinguish people into two broad categories: elites and non-elite people, 
where by elites we mean people who status is included in c("equestrian order", "decurial order, higher local offices", "senatorial order", "equestrian order", "military personnel", "lower local offices, administration of imperial estates", "emperor / imperial household", "rulers (foreign)"), and by non-elites we mean people whose status in included in c("freedmen / freedwomen", "slaves", "Augustales").
Among inscriptions which contain references to occupations,  we find 7358 references to elite people,	1258 references to non-elites, thus yielding a ratio of approximately 5.85 elite people per non-elite person, which is highly unrealistic. (NEED TO CLARIFY THIS)
Note however that most inscriptions with occupations contain no reference to status.

Each occupation is classified in one of nineteen Harris Categories.
For each Harris Category, we count the co-occurrence of of references to elite/non-elite statuses with occupations in that category.
(Rk: At the moment we are only looking at co-occurrence, and thus we do not have a mechanism to check whether the person whose status is mentioned is also the person who performs a given occupation. This can lead to wrong associations, e.g., "Senator X hires a cook" would associate senator and cook, and thus necessitates a more careful assessment of the source material in the future.)
We then compute how commonly elite/on-elite people were employed in a given category (e.g., 10% of non-elite people were employed in clothing-related occupations, but only 1% of elite people were). 
This allows us to determine whether a category was mostly an elite or non-elite one.

We use this information to inflate the counts of occupations in categories dominated by non-elites by a fixed factor, which we arbitrarily fix as between 1 (no inflation) and 5 times with a mean of 3.
Rk: These factors are arbitrary because we do no know exactly how many people were elite or non-elite in Ancient Rome, with estimates of 10000 senators and equites and 200-400k military personnel in a total of 60 million people cited by Wikipedia, which would imply that a huge corrective factor is needed.
A more careful approach would involve assuming simplistically that if one had status, then they would include it in the inscriptions, and thus assuing that those who did not indicate their status were probably non-elites. This would be roughly 3/4 of the total.

#### Implementation
```{r status and occupations}
# assign status to each Harris category
Harris_category_status <- data.frame(
  Harris_Category = sort(unique(occupations_all$Harris_Category)),
  elite = c(TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE,FALSE,TRUE,FALSE,FALSE,FALSE,TRUE,TRUE,TRUE)) #Rk: it contain "Unclassfied" (sic) as category

# for each occupation, classify it as either elite or non elite
occupations_status <- occupations_all[,c("std_spelling","Harris_Category")] %>% 
  unique() %>%
  left_join(Harris_category_status)

# select only occupations actually in the data
occupations_status <- occupations_status[occupations_status$std_spelling %in% col_names_c,]
non_elite_occupations <- occupations_status$std_spelling[!occupations_status$elite]
```

```{r function to inflate a table by a given value}
status_bias_correction <- function(occupation_table, corrective_factor){
  output_table <- occupation_table
  output_table[,non_elite_occupations] <-  output_table[,non_elite_occupations] *corrective_factor
  return(output_table)
}
```

```{r sample the correcive factor from a certain interval and output several examples of corrections}
status_bias_correction_stochastic <- function(occupation_table, cf_min, cf_max, n_samples){
  # initialise empty list
  output_table_list <- list()
  
  # set for reproducibility
  set.seed(123)
  
  # sample corrective factors from triangular distribution
  corrective_factors <- rtri(n = n_samples,
                       min = cf_min,
                       max = cf_max,
                       mode = (cf_min+cf_max)/2)
  
  # fill list with each corrective factor
  for (i in 1:n_samples){
    output_table_list[[i]] <- status_bias_correction(occupation_table,corrective_factors[i])
  }
  
  return(output_table_list)
}
```

### Language OK
Many inscriptions found within the limits of the Roman Empire were written in Greek. These were primarily concentrated in the Eastern Roman Empire. We need to account for them to avoid language bias.

In this section we use the counts of greek inscriptions by geographical units that were computed in the previous sections.
We assume the same distribution of professions in the (not analysed) Greek inscriptions and use their locations to proportionally adjust the occupation tables in the geographical units. 

Create a table of counts of greek-inscription by geographical unit (country or province).
```{r table of greek-inscriptions by location}
# modern country
greek_inscriptions_in_countries_counts <- table(greek_inscriptions_in_countries$country)
greek_inscriptions_in_countries_counts_df <- as.data.frame(greek_inscriptions_in_countries_counts) %>% setNames(c("country","frequency"))

# province
greek_inscriptions_in_provinces_counts <- table(greek_inscriptions_in_provinces$province)
greek_inscriptions_in_provinces_counts_df <- as.data.frame(greek_inscriptions_in_provinces_counts) %>% setNames(c("province","frequency"))
```

As it was the case of Latin inscriptions, only a small proportion of all Greek inscriptions were likely occupation-related.
We compute the proportion of occupation-related inscriptions among all Latin inscriptions and assume the same proportion holds for Greek inscriptions to adjust the inscriptions counts.
We adjust the above tables accordingly to retrieve tables of estimated counts of occupation-related greek inscriptions by geographical unit.
```{r adjust counts for occupation related inscriptions}
# proportion of occupation-related inscriptions among all Latin inscriptions
proportion_occupation_related_Latin_inscriptions <- nrow(inscriptions_w_occupations)/nrow(inscriptions)

# obtain estimates of occupation-related greek inscriptions

# country
greek_inscriptions_w_occupations_in_countries_counts <- greek_inscriptions_in_countries_counts*proportion_occupation_related_Latin_inscriptions 
greek_inscriptions_w_occupations_in_countries_counts_df <- as.data.frame(greek_inscriptions_w_occupations_in_countries_counts) %>% setNames(c("country","frequency"))

#province  
greek_inscriptions_w_occupations_in_provinces_counts <- greek_inscriptions_in_provinces_counts*proportion_occupation_related_Latin_inscriptions 
greek_inscriptions_w_occupations_in_provinces_counts_df <- as.data.frame(greek_inscriptions_w_occupations_in_provinces_counts) %>% setNames(c("province","frequency"))  

# We round these values (NEED TO SEE IF IT MAKES SENSE)
greek_inscriptions_w_occupations_in_countries_counts_df$frequency_rounded <- round(greek_inscriptions_w_occupations_in_countries_counts_df$frequency) 
greek_inscriptions_w_occupations_in_provinces_counts_df$frequency_rounded <- round(greek_inscriptions_w_occupations_in_provinces_counts_df$frequency)
```

Remark that all the values that will follow in this section will be estimates and not real count.
For that, we would need an in-depth analysis of Greek inscriptions that is beyond the scope of this study. 

Compute the distribution of the number of occupation-related inscriptions.
Assign a count of occupations to each occupation-related inscription based on this distribution.
```{r}
# set seed for reproducibility
set.seed(123)

# define the original distribution of the number of occupations per occupation-related Latin inscription 
n_occupations_per_inscription_Latin <- inscriptions_w_occupations$occups_N

# the distribution is heavily left-skewed with a median and mean of 1 and ~1.24 respectively
hist(n_occupations_per_inscription_Latin, 100)

# we sample from the distribution with replacement as many times as the total estimated number of occupation-related Greek inscriptions. 
# we thus obtain a possible number of occupations per each Greek occupation-related inscription.
# we repeat the process 1000 times.
n_iterations <- 1000
sampled_n_occupations_per_greek_inscriptions_in_countries <- replicate(
  n_iterations,
  sample(n_occupations_per_inscription_Latin,
         size = round(sum(greek_inscriptions_w_occupations_in_countries_counts_df$frequency_rounded)),
         replace = TRUE))

sampled_n_occupations_per_greek_inscriptions_in_provinces <- replicate(
  n_iterations,
  sample(n_occupations_per_inscription_Latin,
         size = round(sum(greek_inscriptions_w_occupations_in_provinces_counts_df$frequency_rounded)),
         replace = TRUE))
```

Note that the number of occupation per occupation-related Greek inscription is approximately normally distributed around the mean of the number of occupations per occupation-related Latin inscription (as expected)
```{r visualise mean number of occupations per occupation-related Greek inscriptions}
# by country
hist(colMeans(sampled_n_occupations_per_greek_inscriptions_in_countries),100)
abline(v=mean(n_occupations_per_inscription_Latin), col="red")

# by province
hist(colMeans(sampled_n_occupations_per_greek_inscriptions_in_provinces),100)
abline(v=mean(n_occupations_per_inscription_Latin), col="red")
```

Say that a geographical unit "g_i" contains "n_i" occupation-related inscriptions. 
By summing the first n_1 values of a column of the above sample, we obtain the total number of occupations in g_1. 
By summing the n_2 values between n_1+1 and n_1+n_2 we obtain the total number of occupations in g_2. etc.
We thus obtain counts of occupations in each geographical unit.
```{r total occupations by country (from Greek inscriptions)}
# avoid zeros for simplicity
greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df <- greek_inscriptions_w_occupations_in_countries_counts_df[!greek_inscriptions_w_occupations_in_countries_counts_df$frequency_rounded==0,]

# Initialize an empty matrix to store the results
occupations_in_greek_inscriptions_by_country_counts <- matrix(
  nrow = nrow(greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df), 
  ncol = ncol(sampled_n_occupations_per_greek_inscriptions_in_countries))

# Loop through each pair of start and end indices
end_idx <- 0
start_idx <- 1

for (i in 1:nrow(greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df)) {
  # define end_index
  end_idx <- end_idx + 
    greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df$frequency_rounded[i]
  
  # Calculate the column sums for the specified rows
  if (end_idx > start_idx){
    occupations_in_greek_inscriptions_by_country_counts[i, ] <-
      colSums(sampled_n_occupations_per_greek_inscriptions_in_countries[start_idx:end_idx, ])
  } else {
    
    occupations_in_greek_inscriptions_by_country_counts[i, ]<-
      sampled_n_occupations_per_greek_inscriptions_in_countries[start_idx,]
  }

  # redefine start-index for next iteration
  start_idx <- end_idx +1
  
  # verify
  #all(colSums(sampled_n_occupations_per_greek_inscriptions_in_countries)==colSums(occupations_in_greek_inscriptions_by_country_counts))
}

# give meaningful names to rows and columns
rownames(occupations_in_greek_inscriptions_by_country_counts) <-
  greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df$country
colnames(occupations_in_greek_inscriptions_by_country_counts) <- paste0("it_",1:n_iterations)

# transform in dataframe
occupations_in_greek_inscriptions_by_country_counts_df <- data.frame(
  country = greek_inscriptions_w_occupations_in_countries_counts_no_zeros_df$country
) %>% cbind(occupations_in_greek_inscriptions_by_country_counts)
```

```{r total occupations by province (from Greek inscriptions)}
# avoid zeros for simplicity
greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df <- greek_inscriptions_w_occupations_in_provinces_counts_df[!greek_inscriptions_w_occupations_in_provinces_counts_df$frequency_rounded==0,]

# Initialize an empty matrix to store the results
occupations_in_greek_inscriptions_by_province_counts <- matrix(
  nrow = nrow(greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df), 
  ncol = ncol(sampled_n_occupations_per_greek_inscriptions_in_provinces))

# Loop through each pair of start and end indices
end_idx <- 0
start_idx <- 1

for (i in 1:nrow(greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df)) {
  # define end_index
  end_idx <- end_idx + 
    greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df$frequency_rounded[i]
  
  # Calculate the column sums for the specified rows
  if (end_idx > start_idx){
    occupations_in_greek_inscriptions_by_province_counts[i, ] <-
      colSums(sampled_n_occupations_per_greek_inscriptions_in_provinces[start_idx:end_idx, ])
  } else {
    occupations_in_greek_inscriptions_by_province_counts[i, ]<-
      sampled_n_occupations_per_greek_inscriptions_in_provinces[start_idx,]
  }

  # redefine start-index for next iteration
  start_idx <- end_idx +1
  
  # verify
  all(colSums(sampled_n_occupations_per_greek_inscriptions_in_provinces)==colSums(occupations_in_greek_inscriptions_by_province_counts))
}

# give meaningful names to rows and columns
rownames(occupations_in_greek_inscriptions_by_province_counts) <-
  greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df$province
colnames(occupations_in_greek_inscriptions_by_province_counts) <- paste0("it_",1:n_iterations)

# transform in dataframe
occupations_in_greek_inscriptions_by_province_counts_df <- data.frame(
  province = greek_inscriptions_w_occupations_in_provinces_counts_no_zeros_df$province
) %>% cbind(occupations_in_greek_inscriptions_by_province_counts)
```

For each geographical unit, we have a distribution of occupations as emerged from the Latin inscriptions.
We want to use it to redistribute proportionally the greek occupation counts to specific occupations (in each province).

However, we want to avoid unrealistic situations in which a very large number of Greek inscriptions is assigned very few occupation types, which would be the case for geographical units in which Greek was prevalent and Latin inscriptions very rare.

To see if this situation could arise, we compare counts of Latin and Roman inscriptions by geographical unit.

First by province:
```{r Latin vs Greek counts by province}
# compute total occupation counts by province from Latin inscriptions
occupations_counts_Latin_Greek_comparison_province <- data.frame(
  province = rownames(province_table),
  Latin_counts = rowSums(province_table)
  )
rownames(occupations_counts_Latin_Greek_comparison_province) <- NULL

# add Greek counts
occupations_counts_Latin_Greek_comparison_province <- left_join(
  occupations_counts_Latin_Greek_comparison_province,
  occupations_in_greek_inscriptions_by_province_counts_df)

# assign value zeros to the NA derived from provinces without Greek inscriptions
occupations_counts_Latin_Greek_comparison_province[is.na(occupations_counts_Latin_Greek_comparison_province)] <- 0
```

Then by country: 
```{r Latin vs Greek counts by country}
# compute total occupation counts by province from Latin inscriptions
occupations_counts_Latin_Greek_comparison_country <- data.frame(
  country = rownames(country_table),
  Latin_counts = rowSums(country_table)
  )
rownames(occupations_counts_Latin_Greek_comparison_country) <- NULL

# add Greek counts
occupations_counts_Latin_Greek_comparison_country <- left_join(
  occupations_counts_Latin_Greek_comparison_country,
  occupations_in_greek_inscriptions_by_country_counts_df)

# assign value zeros to the NA derived from provinces without Greek inscriptions
occupations_counts_Latin_Greek_comparison_country[is.na(occupations_counts_Latin_Greek_comparison_country)] <- 0
```

Inspection of the above df reveals that some provinces (resp countries) have very few Latin inscriptions by a large number of Greek inscriptions. 
To mitigate the issue, we draw not just from the distribution of occupations in a geographical unit but also from those of their surroundings (say less than 100km. This is an arbitrary threshold meant to reflect similar environmental and social conditions TO BE DEBATED). 

Find surroundings of the provinces and countries.
```{r surroundings of provinces and countries}
# compute the distances between provinces
distance_between_provinces <- st_distance(provinces) 
province_names <- provinces$province
rownames(distance_between_provinces) <- province_names
colnames(distance_between_provinces) <- province_names

# distance between countries: note it include countries beyond the borders of the empire that include greek inscriptions
selected_countries <- world_sf[world_sf$iso3 %in% occupations_in_greek_inscriptions_by_country_counts_df$country,] 
selected_countries <- selected_countries[,c("iso3","geometry")]

# "PSE" (Palestine) appears twice (one territory corresponds to the West Bank and the other to the Gaza Strip). We combine them as one geometric object to avoid repeated rows and columns in the distance table. 
selected_countries$geometry[selected_countries$iso3 == "PSE"] <- st_union(
  na.omit(selected_countries[selected_countries$iso3=="PSE",]))
selected_countries <- unique(selected_countries)

# now compute the distances between the selected countries
distance_between_countries <- st_distance(selected_countries)
selected_country_codes <- selected_countries$iso3
rownames(distance_between_countries) <- selected_country_codes
colnames(distance_between_countries) <- selected_country_codes

# set maximum distance to include in the surroundings
max_distance <- set_units(100000,"m")

# initialise empty list of surroundings for provinces
surrounding_list_provinces <- list()

# for each province, add an entry to the list with its surroundings
for (province in province_names){
  surrounding_list_provinces[[province]] <- province_names[which(distance_between_provinces[province,]<max_distance)]
}

# inialise empty list of surrroundings for countries
surrounding_list_countries <- list()

# for each country, add an entry to the list with its surroundings
for (country in selected_country_codes){
  surrounding_list_countries[[country]] <- selected_country_codes[which(distance_between_countries[country,]<max_distance)]
}
```

Find table of occupations for geographical unit plus its surroundings.
```{r table of occupations in surroundings}
# initialise table for provinces
province_and_surroundings_table <- province_table

# add together the table values 
# rk : we cannot substitute rownames(province_table) with province_names as not all provinces contained inscriptions (Alpes Poeninae does not)
for (province in rownames(province_table)) {
  province_and_surroundings_table[province,] <- province_table[rownames(province_table) %in% surrounding_list_provinces[[province]],] %>%
    colSums()
}

# initialise table for provinces
country_and_surroundings_table <- country_table

# add together the table values 
# rk : we cannot substitute rownames(province_table) with province_names as not all provinces contained inscriptions (Alpes Poeninae does not)
for (country in rownames(country_table)) {
  country_and_surroundings_table[country,] <- country_table[rownames(country_table) %in% surrounding_list_countries[[country]],] %>%
    colSums()
}
```

Now that we have the distribution, we want to sample with replacement from this set with sample size equal to the estimated number of occupation-related Greek inscriptions. This will give us an estimated distribution of occupations deriving from the Greek inscriptions

```{r sample occupations from provinces and surroundings}
#initialise the list
province_table_greek_list <- list()

# for reproducibility
set.seed(1)

for (i in 1:n_iterations) {
  #initialise table
  province_table_greek <- province_table
  province_table_greek[,] <- 0
  
  # build
  for (province in rownames(province_table)) {
    if (province %in% occupations_in_greek_inscriptions_by_province_counts_df$province){
      # extract the info for a province
      province_counts <- province_and_surroundings_table[province,]
      # convert into a distribution of occupations. Each occupation appears as many times as the province 
      province_distribution <- rep(names(province_counts),province_counts)
      # sample
      occupations_sample <- sample(
        province_distribution,
        size = occupations_in_greek_inscriptions_by_province_counts_df[province,i+1],
        replace = TRUE
      )
    
      # as table
      occupations_sample_table <- table(occupations_sample)
    
      # add to the table
      province_table_greek[province,names(occupations_sample_table)] <- occupations_sample_table
    }
  }
  
  # add to the list
  province_table_greek_list[[paste0("it_",i)]] <- province_table_greek
  
  # check progression
  if (i %%100 ==0){
    print(paste(i,"iterations out of",n_iterations,"completed."))
  }
}
```

Repeat the same for countries
```{r sample occupations from countries and surroundings}
#initialise the list
country_table_greek_list <- list()

# for reproducibility
set.seed(1)

for (i in 1:n_iterations) {
  #initialise table
  country_table_greek <- country_table
  country_table_greek[,] <- 0
  
  # build
  for (country in rownames(country_table)) {
    if (country %in% occupations_in_greek_inscriptions_by_country_counts_df$country){
      # extract the info for a country
      country_counts <- country_and_surroundings_table[country,]
      # convert into a distribution of occupations. Each occupation appears as many times as the country 
      country_distribution <- rep(names(country_counts),country_counts)
      # sample
      occupations_sample <- sample(
        country_distribution,
        size = occupations_in_greek_inscriptions_by_country_counts_df[country,i+1],
        replace = TRUE
      )
    
      # as table
      occupations_sample_table <- table(occupations_sample)
    
      # add to the table
      country_table_greek[country,names(occupations_sample_table)] <- occupations_sample_table
    }
  }
  
  # add to the list
  country_table_greek_list[[paste0("it_",i)]] <- country_table_greek
  
  # check progression
  if (i %%100 ==0){
    print(paste(i,"iterations out of",n_iterations,"completed."))
  }
}
```

We convert the data into dataframes and save it.
```{r convert province lists to df}
# Convert each table to a long format data frame
province_table_greek_long <- lapply(province_table_greek_list, function(tbl) {
  data.frame(row = rep(rownames(tbl), times = ncol(tbl)),
             col = rep(colnames(tbl), each = nrow(tbl)),
             freq = as.vector(tbl))})

# Name each frequency column uniquely
for (i in seq_along(province_table_greek_long)) {
  names(province_table_greek_long[[i]])[3] <- paste0("freq_", i)
}

# Merge all long format tables into a single data frame by row and col
province_table_greek_long_df <- Reduce(function(x, y) merge(x, y, by = c("row", "col")), province_table_greek_long)

# write results
write.csv(province_table_greek_long_df,
          "../../results/economic_complexity/greek_occupations_by_province.csv")
```

Do the same for countries
```{r convert country list to df}
# Convert each table to a long format data frame
country_table_greek_long <- lapply(country_table_greek_list, function(tbl) {
  data.frame(row = rep(rownames(tbl), times = ncol(tbl)),
             col = rep(colnames(tbl), each = nrow(tbl)),
             freq = as.vector(tbl))})

# Name each frequency column uniquely
for (i in seq_along(country_table_greek_long)) {
  names(country_table_greek_long[[i]])[3] <- paste0("freq_", i)
}

# Merge all long format tables into a single data frame by row and col
country_table_greek_long_df <- Reduce(function(x, y) merge(x, y, by = c("row", "col")), country_table_greek_long)

# write results
write.csv(country_table_greek_long_df,
          "../../results/economic_complexity/greek_occupations_by_country.csv")
```


Finally we add the tables of greek and latin inscriptions together to obtain the result 
```{r add the tables}
# provinces
province_table_greek_latin_list<-list()
for(i in 1:n_iterations){
  # sum
  province_table_greek_latin <- province_table_greek_list[[paste0("it_",i)]] + province_table
  
  # sort
  # col names (occupations, sorted by frequency)
  col_names_p_gl <- names(
    sort(
      colSums(province_table_greek_latin),
      decreasing=TRUE)
    )
  
  # row names (countries, sorted by total counts)
  row_names_p_gl <- names(
    sort(
      rowSums(province_table_greek_latin),
      decreasing=TRUE)
    )
  
  # sort based on row and column counts
  province_table_greek_latin <- province_table_greek_latin[row_names_p_gl,col_names_p_gl]

  # add to list
  province_table_greek_latin_list[[paste0("it_",i)]] <- province_table_greek_latin 
}

# countries
country_table_greek_latin_list<-list()
for(i in 1:n_iterations){
  # sum
  country_table_greek_latin <- country_table_greek_list[[paste0("it_",i)]] + country_table
  
  # sort
  # col names (occupations, sorted by frequency)
  col_names_c_gl <- names(
    sort(
      colSums(country_table_greek_latin),
      decreasing=TRUE)
    )
  
  # row names (countries, sorted by total counts)
  row_names_c_gl <- names(
    sort(
      rowSums(country_table_greek_latin),
      decreasing=TRUE)
    )
  
  # sort based on row and column counts
  country_table_greek_latin <- country_table_greek_latin[row_names_c_gl,col_names_c_gl]

  # add to list
  country_table_greek_latin_list[[paste0("it_",i)]] <- country_table_greek_latin 
}

```

Example heat map
```{r}
province_latin_and_greek_table_heatmap <- as.data.frame(province_table_greek_latin_list[["it_1"]]) %>% setNames(c("province","occupation","frequency"))
province_latin_and_greek_table_heatmap$log_frequency <- log(province_latin_and_greek_table_heatmap$frequency)

province_latin_and_greek_table_heatmap_plot <- ggplot(province_latin_and_greek_table_heatmap, aes(occupation, province, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "province", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by province") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))

print(province_latin_and_greek_table_heatmap_plot)
```

One thing that looks odd to me is the fact that for the Greek-speaking regions we are sampling many times from a limited pool of occupations that lead to very concentrated distribution of job types. This diminishes the "lower triangularity" of the matrix. We might have to expand the pool to the entire system. This can be done by adjusting the threshold :)

## Specialisation function for updates TO DO NOT PRIORITY
We create a function to subdivide an occupation into suboccupations as new evidence is gathered

## Apply bias correction TO DO (in different orders)

### Attempt with province table.
Order to follow:
1. Language
2. Research bias
3. Status bias
4. Gender
5  Agricola

#### 1. Language
```{r 1. Language}
# 1. Language
# select one of the many precomputed ones:
start_table <- province_table[!rownames(province_table)%in%c("Eastern border","North-eastern border"),]

table_step_1 <- province_table_greek_latin_list[[1]]

# delete the border regions (WILL HAVE TO BE DONE FROM THE START LATER ON)
table_step_1 <- table_step_1[!rownames(table_step_1)%in%c("Eastern border","North-eastern border"),]
```

#### 2. Research bias
Repeat the same for provinces.
```{r rescale by epitaph per person}
# Latin epitaph counts by province 
epitaphs_in_provinces_counts_2 <- epitaphs_in_provinces_counts
rownames(epitaphs_in_provinces_counts_2) <- epitaphs_in_provinces_counts_2$province
epitaphs_in_provinces_counts_2<-epitaphs_in_provinces_counts_2[rownames(table_step_1),]
colnames(epitaphs_in_provinces_counts_2) <- c("province","latin_epitaphs")

# count of greek inscriptions (include also those with 0)
greek_inscriptions_in_provinces_counts_df_2 <- greek_inscriptions_in_provinces_counts_df 
greek_inscriptions_in_provinces_counts_df_2 <- rbind(greek_inscriptions_in_provinces_counts_df_2,
                                                     data.frame(province = c("Alpes Maritimae","Alpes Graiae"), 
                                                                frequency = c(0,0)))
rownames(greek_inscriptions_in_provinces_counts_df_2) <- greek_inscriptions_in_provinces_counts_df_2$province
greek_inscriptions_in_provinces_counts_df_2 <- greek_inscriptions_in_provinces_counts_df_2[rownames(table_step_1),]

# count total inscriptions and ratio of assume same ratio of funerary ones
epitaphs_in_provinces_counts_2$greek_epitaphs <- epitaphs_in_provinces_counts_2$latin_epitaphs*greek_inscriptions_in_provinces_counts_df_2$frequency/rowSums(start_table[rownames(table_step_1),])

epitaphs_in_provinces_counts_2$epitaphs <- epitaphs_in_provinces_counts_2$latin_epitaphs+epitaphs_in_provinces_counts_2$greek_epitaphs

# initialise data frame of bias 
ratio_epitaphs_pop_provinces_2 <- data.frame(
  province = rownames(table_step_1)) %>% 
  left_join(provinces_population_df[,c("province","tot_pop_min","tot_pop_max")]) %>%
  left_join(epitaphs_in_provinces_counts_2)

# add columns of ratios between population estimates and epitaphs counts
ratio_epitaphs_pop_provinces_2$people_per_epitaph_min <- ratio_epitaphs_pop_provinces_2$tot_pop_min/ratio_epitaphs_pop_provinces_2$epitaphs
ratio_epitaphs_pop_provinces_2$people_per_epitaph_max <- ratio_epitaphs_pop_provinces_2$tot_pop_max/ratio_epitaphs_pop_provinces_2$epitaphs

rownames(ratio_epitaphs_pop_provinces_2) <- ratio_epitaphs_pop_provinces_2$province

# sort info
ratio_epitaphs_pop_provinces_2<-ratio_epitaphs_pop_provinces_2[rownames(table_step_1),]

# rescale by minimum people per epitaph
table_step_2_min <- table_step_1*ratio_epitaphs_pop_provinces_2$people_per_epitaph_min
```

#### 3. Status bias
```{r}
table_step_3_min <- status_bias_correction_stochastic(table_step_2_min,3,5,1)[[1]]
```


#### 4. Gender

```{r}
table_step_4_min <-  gender_bias(table_step_3_min,gender_ratio_v[1])
```

#### 5. Agricola
```{r}
table_step_5_min <- agricola_correction(table_step_4_min,0.95)$min
write.csv(table_step_5_min,"../../results/economic_complexity/table_step_5_min.csv")

write.csv(start_table,"../../results/economic_complexity/start_table.csv")
```

```{r}
start_table_heatmap <- as.data.frame(start_table) %>% setNames(c("province","occupation","frequency"))
start_table_heatmap$log_frequency <- log(start_table_heatmap$frequency)

start_table_heatmap_plot <- ggplot(start_table_heatmap, aes(occupation, province, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "province", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by province") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))

print(start_table_heatmap_plot)
```


```{r}
table_step_5_min_heatmap <- as.data.frame(table_step_5_min) %>% setNames(c("province","occupation","frequency"))
table_step_5_min_heatmap$log_frequency <- log(table_step_5_min_heatmap$frequency)

table_step_5_min_heatmap_plot <- ggplot(table_step_5_min_heatmap, aes(occupation, province, fill=log_frequency)) + 
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "occupation", 
       y = "province", 
       fill ="log(frequency)",
       title = "Frequency of occupations in inscriptions by province") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 2))

print(table_step_5_min_heatmap_plot)
```

```{r}
a <- numeric(54)
for (i in 1:54){
  a[i] <- which(rownames(table_step_5_min)==rownames(start_table)[i])
}

change_in_rank_df <- data.frame(province = rownames(table_step_5_min),
                                new_rank = a,
                                old_rank = 1:54,
                                change_in_rank = a-1:54)
```

